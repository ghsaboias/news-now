This file is an optimized merged representation of the codebase, prioritizing TypeScript and essential files.
Generated by Python script on: 2025-03-07T15:06:27.516514Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file provides a concise representation of the repository's essential contents,
with a focus on TypeScript (.ts, .tsx) and other key source files for AI analysis.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents (if small), truncated content, or summary (if large)
</file_format>

<usage_guidelines>
- This file is read-only. Edit the original repository files instead.
- Use file paths to distinguish between files.
- Handle with care due to potential sensitive information.
</usage_guidelines>

<notes>
- Excluded: common libraries (e.g., node_modules, dist), binary files, and non-essential types.
- Large files (>50KB) are summarized with metadata.
- Content longer than 10,000 characters is truncated.
- Prioritized file types: .ts, .tsx, .js, .md, .html, .json, .css, .py.
</notes>

<additional_info>

</additional_info>
</file_summary>

<directory_structure>
news-now/
  .gitignore
  README.md
  repo_summary_optimized_ts.txt
  test.md
new-app/
  .eslintrc.js
  README.md
  eslint.config.mjs
  next.config.ts
  package.json
  postcss.config.mjs
  tailwind.config.ts
  tsconfig.json
  public/
    favicon.png
    file.svg
    globe.svg
    window.svg
  src/
    types.ts
    context/
      ReportsContext.tsx
      ToastContext.tsx
    app/
      favicon.ico
      globals.css
      layout.tsx
      page.tsx
      api/
        messages/
          route.ts
        summary/
          route.ts
        channels/
          route.ts
      summarizer/
        layout.tsx
        page.tsx
    utils/
      config.ts
    components/
      layout/
        Stack.tsx
      controls/
        ChannelSelect.tsx
        ControlsContainer.tsx
        TimeSelect.tsx
      common/
        Button.tsx
        EmptyStateMessage.tsx
        Toast.tsx
    hooks/
      useDiscordChannels.ts
    services/
      discord/
        client.ts
      claude/
        client.ts
      report/
        generator.ts
</directory_structure>

<files>
This section contains the optimized contents of the repository's files.

<file path=".gitignore">
# dependencies
/node_modules
/.pnp
.pnp.js
**/node_modules/

# testing
/coverage

# next.js
/.next/
/out/
/build
**/.next/
**/out/
**/build/

# production
/build
*.tar.gz
build.tar.gz
**/dist/

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local
.env

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# IDE
.idea
.vscode

# Default Next.js assets we don't need
/public/next.svg
/public/vercel.svg

# Python legacy
.venv
__pycache__/
bot.log
formatted_text.txt

# Data and logs
data/
logs/
memory/

# Sensitive files
.env*
.cursorrules

# Old documentation files (now consolidated in docs/)
DEPLOYMENT.md
DEPLOYMENT_PROTOCOL.md
CONFIGURATION.md
UI_IMPROVEMENT_PLAN.md
TODO.md
STRUCTURE.md
THEME_DOC.md
COMPONENT_COMPOSITION.md
DB_INTEGRATION.md
DB_DOCUMENTATION.md
REDIS.md
docs/

scripts/

# Cursor
.cursor/

# App AI World
app-aiworld.service
**/app-aiworld.service
new-app/app-aiworld.service

# Cursor Rules
.cursor/rules/

</file>

<file path="README.md">
# NewsNow

Transform real-time discussions into clear, concise summaries powered by AI. Stay on top of your communities without the overwhelm.

## Project Evolution

NewsNow has evolved from a Python-based application to a modern Next.js implementation, focusing on improved performance, better user experience, and maintainable code. The project maintains both implementations:

## Features

- **Real-Time Processing**: Stream and process messages in real-time
- **Smart Summarization**: AI-powered summaries of channel discussions
- **Flexible Timeframes**: Generate reports for 1-hour, 4-hour, or 24-hour periods
- **Report Management**: Save, view, and manage generated reports
- **Modern UI**: Clean, responsive interface built with Next.js and Tailwind CSS

## Tech Stack

- **Framework**: Next.js 14 (App Router)
- **Language**: TypeScript
- **Styling**: Tailwind CSS
- **State Management**: React Context
- **UI Components**: Custom components with Tailwind
- **Icons**: Feather Icons
- **Database**: SQLite with better-sqlite3

## Getting Started

### Prerequisites

- Node.js 20.x or later
- npm or yarn

### Installation

1. Clone the repository:
```bash
git clone https://github.com/ghsaboias/news-now.git
cd news-now/new-app
```

2. Install dependencies:
```bash
npm install
# or
yarn install
```

3. Create a `.env.local` file:
```env
DISCORD_TOKEN=your_discord_bot_token
ANTHROPIC_API_KEY=your_api_key
```

4. Run the development server:
```bash
npm run dev
# or
yarn dev
```

5. Open [http://localhost:3000](http://localhost:3000) in your browser

## Project Structure

```
news-now/
├── docs/               # Detailed documentation
└── new-app/           # Next.js implementation
    ├── src/
    │   ├── app/       # Next.js app router pages
    │   ├── components/# React components
    │   ├── context/   # React context providers
    │   ├── services/  # Business logic and services
    │   └── types/     # TypeScript type definitions
    ├── public/        # Static assets
    └── data/          # Local data storage
```

## Key Components

- **Real-Time Integration**: Message fetching and processing
- **Report Generation**: AI-powered summarization of discussions
- **Storage System**: Local file-based storage for reports
- **UI Components**: Reusable components for consistent design

## Development

### Commands

```bash
# Start development server
npm run dev

# Build for production
npm run build

# Start production server
npm start

# Run type checking
npm run type-check

# Run linting
npm run lint
```

### Code Style

- TypeScript for type safety
- ESLint for code linting
- Prettier for code formatting

## Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details. 
</file>

<file path="repo_summary_optimized_ts.txt">
[File type excluded: .txt]
</file>

<file path="test.md">
graph TD
subgraph "Frontend"
HomePage["Home Page (page.tsx)"]
SummarizerPage["Summarizer Page (summarizer/page.tsx)"]

        subgraph "Components"
            Controls["Controls (ChannelSelect, TimeSelect)"]
            Common["Common UI (Button, Toast, EmptyState)"]
            Layout["Layout (Stack)"]
        end

        subgraph "Context"
            ReportsContext["ReportsContext (Report state)"]
            ToastContext["ToastContext (Notifications)"]
        end

        subgraph "Hooks"
            useDiscordChannels["useDiscordChannels (Fetch channels)"]
        end
    end

    subgraph "Backend"
        subgraph "API Routes"
            MessagesAPI["Messages API (api/messages/route.ts)"]
            SummaryAPI["Summary API (api/summary/route.ts)"]
            ChannelsAPI["Channels API (api/channels/route.ts)"]
        end

        subgraph "Services"
            DiscordClient["Discord Client (discord/client.ts)"]
            ClaudeClient["Claude Client (claude/client.ts)"]
            ReportGenerator["Report Generator (report/generator.ts)"]
        end
    end

    subgraph "Types"
        CoreTypes["Core Types (types.ts)"]
    end

    %% Data Flow
    HomePage --> SummarizerPage
    SummarizerPage --> Controls
    SummarizerPage --> ReportsContext
    SummarizerPage --> ToastContext
    SummarizerPage --> useDiscordChannels
    SummarizerPage --> MessagesAPI
    SummarizerPage --> SummaryAPI

    Controls --> Common
    Controls --> Layout

    useDiscordChannels --> DiscordClient
    useDiscordChannels --> ChannelsAPI

    MessagesAPI --> DiscordClient
    SummaryAPI --> ClaudeClient
    SummaryAPI --> ReportGenerator

    ReportGenerator --> ClaudeClient

    DiscordClient -.-> CoreTypes
    ClaudeClient -.-> CoreTypes
    ReportGenerator -.-> CoreTypes
    ReportsContext -.-> CoreTypes

</file>

<file path="new-app/.eslintrc.js">
module.exports = {
  extends: ["next/core-web-vitals"],
  rules: {
    "@typescript-eslint/no-unused-vars": [
      "error",
      {
        argsIgnorePattern: "^_",
        varsIgnorePattern: "^_",
        ignoreRestSiblings: true,
      },
    ],
    "@typescript-eslint/no-explicit-any": "warn",
    "react-hooks/exhaustive-deps": "warn",
    "react/display-name": "off",
    "no-console": ["warn", { allow: ["warn", "error"] }],
    "import/order": [
      "warn",
      {
        groups: [
          "builtin",
          "external",
          "internal",
          "parent",
          "sibling",
          "index",
        ],
        "newlines-between": "always",
        alphabetize: { order: "asc" },
      },
    ],
  },
  env: { browser: true, node: true },
};

</file>

<file path="new-app/README.md">
# NewsNow Next.js Implementation

Modern, production-ready implementation of NewsNow using Next.js and TypeScript. For the complete project documentation, see the [root README](../README.md).

## Quick Start

```bash
# Install dependencies
npm install

# Set up environment variables
cp .env.example .env.local
# Edit .env.local with your credentials

# Start development server
npm run dev
```

## Development

### Key Technologies

- **Next.js 15** with App Router
- **TypeScript** for type safety
- **Tailwind CSS** for styling
- **SQLite** with better-sqlite3
- **Jest** for testing

### Available Scripts

```bash
npm run dev          # Start development server
npm run build        # Build for production
npm start           # Start production server
npm test           # Run tests
npm run lint        # Run linting
```

### Environment Variables

Required environment variables:

```env
DISCORD_TOKEN=       # Discord bot token
ANTHROPIC_API_KEY=   # Anthropic API key for Claude
```

### Project Structure

```
src/
├── app/             # Next.js pages and API routes
├── components/      # React components
│   ├── common/      # Shared UI components
│   ├── controls/    # Application controls
│   ├── layout/      # Layout components
│   └── reports/     # Report-related components
├── context/         # React context providers
├── hooks/           # Custom React hooks
├── services/        # Business logic
└── types/          # TypeScript definitions
```

### Component Architecture

- **Atomic Design** principles
- Composition over inheritance
- Custom hooks for reusable logic
- Context for state management

### Testing Strategy

- Jest + React Testing Library
- Unit tests for components
- Integration tests for features
- E2E tests for critical flows

### Performance Optimizations

- Server components where possible
- Optimized images and fonts
- Code splitting and lazy loading
- Efficient database queries

### Style Guide

- ESLint + Prettier configuration
- TypeScript strict mode
- Tailwind CSS class ordering
- Component composition patterns

## Deployment

For detailed deployment instructions, see the [Deployment Guide](../docs/DEPLOYMENT.md).

Quick deployment checklist:

1. Build the application
2. Set up environment variables
3. Configure database
4. Start the server

## Contributing

1. Follow the style guide
2. Write tests for new features
3. Update documentation
4. Create focused pull requests

</file>

<file path="new-app/eslint.config.mjs">
[File type excluded: .mjs]
</file>

<file path="new-app/next.config.ts">
export default {
  output: 'standalone',
  poweredByHeader: false,
  compress: true,
  images: { domains: ['cdn.discordapp.com'] },
  eslint: { ignoreDuringBuilds: true }
};
</file>

<file path="new-app/package.json">
{
  "name": "new-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@anthropic-ai/sdk": "^0.33.1",
    "@tailwindcss/typography": "^0.5.16",
    "axios": "^1.8.2",
    "better-sqlite3": "^9.0.0",
    "clsx": "^2.1.1",
    "next": "15.1.4",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-feather": "^2.0.10",
    "tailwind-merge": "^2.6.0"
  },
  "devDependencies": {
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.1.4",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "typescript": "^5"
  }
}

</file>

<file path="new-app/postcss.config.mjs">
[File type excluded: .mjs]
</file>

<file path="new-app/tailwind.config.ts">
import type { Config } from "tailwindcss";

const config: Config = {
  content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      colors: {
        // Core grays for dark theme
        gray: {
          50: '#F8FAFC',  // Primary text on dark (contrast ratio: 15.8:1)
          100: '#F1F5F9', // Secondary text on dark (contrast ratio: 13.5:1)
          200: '#E2E8F0', // Tertiary text on dark (contrast ratio: 11.3:1)
          300: '#CBD5E1', // Muted text on dark (contrast ratio: 9.5:1)
          400: '#94A3B8', // Subtle text on dark (contrast ratio: 5.8:1)
          500: '#64748B', // Disabled text on dark (contrast ratio: 3.5:1)
          600: '#475569', // Borders and dividers
          700: '#334155', // Surface hover
          800: '#1E293B', // Surface
          900: '#0F172A', // Background
        },
        // Primary blue for actions
        blue: {
          50: '#eff6ff',   // Hover light
          100: '#dbeafe',  // Active light
          200: '#bfdbfe',  // Disabled
          300: '#93c5fd',  // Icons light
          400: '#60A5FA', // Interactive hover (contrast ratio: 4.5:1)
          500: '#3B82F6', // Interactive focus (contrast ratio: 5.3:1)
          600: '#2563EB', // Interactive default (contrast ratio: 7:1)
          700: '#1D4ED8', // Interactive pressed (contrast ratio: 8.5:1)
          800: '#1e40af',  // Primary active
          900: '#1e3a8a',  // Primary dark
        },
        // Semantic colors
        success: {
          50: '#f0fdf4',
          100: '#dcfce7',
          500: '#22c55e',
          600: '#16a34a',
          700: '#15803d',
        },
        warning: {
          50: '#fffbeb',
          100: '#fef3c7',
          500: '#f59e0b',
          600: '#d97706',
          700: '#b45309',
        },
        error: {
          50: '#fef2f2',
          100: '#fee2e2',
          400: '#F87171', // Error hover (contrast ratio: 4.5:1)
          500: '#EF4444', // Error default (contrast ratio: 5.3:1)
          600: '#DC2626', // Error pressed (contrast ratio: 7:1)
          700: '#b91c1c',
        },
      },
      // Typography scale
      fontSize: {
        'xs': ['0.75rem', { lineHeight: '1rem' }],     // 12px - Badges, metadata
        'sm': ['0.875rem', { lineHeight: '1.25rem' }], // 14px - Body small
        'base': ['1rem', { lineHeight: '1.5rem' }],    // 16px - Body
        'lg': ['1.125rem', { lineHeight: '1.75rem' }], // 18px - Subheadings (h4)
        'xl': ['1.25rem', { lineHeight: '1.75rem' }],  // 20px - Section titles (h3)
        '2xl': ['1.5rem', { lineHeight: '2rem' }],     // 24px - Major sections (h2)
        '3xl': ['1.875rem', { lineHeight: '2.25rem' }], // 30px - Page titles (h1)
        '4xl': ['2.25rem', { lineHeight: '2.5rem' }],  // 36px - Hero titles (h1)
        '5xl': ['3rem', { lineHeight: '1.15' }],      // 48px - Large hero titles (h1)
      },
      lineHeight: {
        none: '1',           // For single-line text
        tight: '1.15',       // For large headings
        snug: '1.25',        // For subheadings
        normal: '1.5',       // For body text
        relaxed: '1.625',    // For longer body text
        loose: '1.75',        // For improved readability
      },
      // Spacing system
      spacing: {
        '0': '0',
        '1': '0.25rem',  // 4px  - Minimal spacing
        '2': '0.5rem',   // 8px  - Tight spacing
        '3': '0.75rem',  // 12px - Default spacing
        '4': '1rem',     // 16px - Component spacing
        '6': '1.5rem',   // 24px - Section spacing
        '8': '2rem',     // 32px - Large spacing
        '12': '3rem',    // 48px - Page spacing
      },
      // Shadows
      boxShadow: {
        sm: '0 1px 2px 0 rgb(0 0 0 / 0.05)',
        DEFAULT: '0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)',
        md: '0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)',
        lg: '0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)',
      },
      // Transitions
      transitionDuration: {
        fast: '150ms',
        DEFAULT: '200ms',
        slow: '300ms',
      },
      transitionTimingFunction: {
        DEFAULT: 'cubic-bezier(0.4, 0, 0.2, 1)',
      },
      // Animations
      keyframes: {
        'fade-in': {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' }
        },
        'fade-out': {
          '0%': { opacity: '1' },
          '100%': { opacity: '0' }
        }
      },
      animation: {
        'fade-in': 'fade-in 5s ease-out',
        'fade-out': 'fade-out 5s ease-in forwards'
      },
      // Typography plugin config
      typography: {
        DEFAULT: {
          css: {
            color: '#f1f5f9', // gray-100
            p: {
              marginTop: '1.5em',
              marginBottom: '1.5em',
              textAlign: 'justify'
            }
          }
        }
      },
      // Heading styles
      heading: {
        h1: {
          fontSize: ['text-3xl', 'sm:text-4xl'],
          lineHeight: 'leading-tight',
          fontWeight: 'font-medium',
          marginBottom: 'mb-4'
        },
        h2: {
          fontSize: ['text-2xl', 'sm:text-3xl'],
          lineHeight: 'leading-tight',
          fontWeight: 'font-medium',
          marginBottom: 'mb-3'
        },
        h3: {
          fontSize: ['text-xl', 'sm:text-2xl'],
          lineHeight: 'leading-snug',
          fontWeight: 'font-medium',
          marginBottom: 'mb-2'
        },
        h4: {
          fontSize: ['text-lg', 'sm:text-xl'],
          lineHeight: 'leading-snug',
          fontWeight: 'font-medium',
          marginBottom: 'mb-2'
        }
      }
    },
  },
};

export default config;

</file>

<file path="new-app/tsconfig.json">
{
    "compilerOptions": {
      "target": "es5",
      "lib": ["dom", "dom.iterable", "esnext"],
      "allowJs": true,
      "skipLibCheck": true,
      "strict": true,
      "noEmit": true,
      "esModuleInterop": true,
      "module": "esnext",
      "moduleResolution": "bundler",
      "resolveJsonModule": true,
      "isolatedModules": true,
      "jsx": "preserve",
      "incremental": true,
      "plugins": [
        {
          "name": "next"
        }
      ],
      "paths": {
        "@/*": ["./src/*"]
      }
    },
    "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
    "exclude": ["node_modules"]
  } 
</file>

<file path="new-app/public/favicon.png">
[File type excluded: .png]
</file>

<file path="new-app/public/file.svg">
[File type excluded: .svg]
</file>

<file path="new-app/public/globe.svg">
[File type excluded: .svg]
</file>

<file path="new-app/public/window.svg">
[File type excluded: .svg]
</file>

<file path="new-app/src/types.ts">
// Discord Types
export interface DiscordMessage {
    id: string;
    content: string;
    timestamp: string;
    author: {
        username: string;
        discriminator: string;
    };
    embeds?: { title?: string; description?: string; fields?: { name: string; value: string }[] }[];
}

// Report Types
export interface AISummary {
    headline: string;
    location: string;
    body: string;
    sources: string[];
    raw_response: string;
    timestamp: string;
    period_start: string;
    period_end: string;
}

export interface Report {
    id: string;
    channelId: string;
    channelName: string;
    timestamp: string;
    timeframe: { type: '1h' | '4h' | '24h'; start: string; end: string };
    messageCount: number;
    summary: AISummary;
}

// Claude AI Types
export interface ClaudeMessage {
    role: 'user' | 'assistant' | 'system';
    content: string;
}

export interface ClaudeResponse {
    content: { text: string }[];
}

export interface ClaudeClient {
    messages: {
        create: (options: {
            model: string;
            max_tokens: number;
            system: string;
            messages: ClaudeMessage[];
        }) => Promise<ClaudeResponse>;
    };
}

export interface DiscordChannel {
    id: string;
    name: string;
    type: number;
    position: number;
    parent_id: string;
}
</file>

<file path="new-app/src/context/ReportsContext.tsx">
'use client';

import type { Report } from '@/types';
import { createContext, ReactNode, useContext, useState } from 'react';

interface ReportsContextType {
  currentReport: Report | null;
  setCurrentReport: (report: Report | null) => void;
}

const ReportsContext = createContext<ReportsContextType | null>(null);

export function ReportsProvider({ children }: { children: ReactNode }) {
  const [currentReport, setCurrentReport] = useState<Report | null>(null);

  return (
    <ReportsContext.Provider value={{ currentReport, setCurrentReport }}>
      {children}
    </ReportsContext.Provider>
  );
}

export function useReports() {
  const context = useContext(ReportsContext);
  if (!context) {
    throw new Error('useReports must be used within a ReportsProvider');
  }
  return context;
}
</file>

<file path="new-app/src/context/ToastContext.tsx">
'use client';

import { createContext, ReactNode, useCallback, useContext, useState } from 'react';

interface Toast {
  text: string;
  type?: 'success' | 'error' | 'info';
}

interface ToastContextType {
  showToast: (message: string | Toast) => void;
}

const ToastContext = createContext<ToastContextType | null>(null);

export function ToastProvider({ children }: { children: ReactNode }) {
  const [toast, setToast] = useState<Toast | null>(null);

  const showToast = useCallback((message: string | Toast) => {
    const toastData = typeof message === 'string' ? { text: message } : message;
    setToast(toastData);

    // Auto-hide after 3 seconds
    setTimeout(() => {
      setToast(null);
    }, 3000);
  }, []);

  return (
    <ToastContext.Provider value={{ showToast }}>
      {children}
      {/* Toast UI */}
      {toast && (
        <div className="fixed bottom-4 right-4 z-50">
          <div className={`
                        px-4 py-2 rounded-lg shadow-lg
                        ${toast.type === 'error' ? 'bg-red-500' :
              toast.type === 'success' ? 'bg-green-500' :
                'bg-blue-500'} 
                        text-white
                    `}>
            {toast.text}
          </div>
        </div>
      )}
    </ToastContext.Provider>
  );
}

export function useToast() {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error('useToast must be used within a ToastProvider');
  }
  return context;
}

</file>

<file path="new-app/src/app/favicon.ico">
[File type excluded: .ico]
</file>

<file path="new-app/src/app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Base Styles */
body {
  @apply text-gray-50 bg-gray-900;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

/* Animation Keyframes */
@layer utilities {
  @keyframes fade-out {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes fade-in {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  .animate-fade-out {
    animation: fade-out 200ms cubic-bezier(0.4, 0, 0.2, 1);
  }

  .animate-fade-in {
    animation: fade-in 200ms cubic-bezier(0.4, 0, 0.2, 1);
  }
}

</file>

<file path="new-app/src/app/layout.tsx">
import { ToastProvider } from '@/context/ToastContext';
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "News Now",
  description: "AI-powered Discord news summarizer",
  icons: {
    icon: '/favicon.png',
  },
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" className="h-full bg-gray-900">
      <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      </head>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased h-full`}
      >
        <ToastProvider>
          {children}
        </ToastProvider>
      </body>
    </html>
  );
}

</file>

<file path="new-app/src/app/page.tsx">
'use client';

import { Stack } from '@/components/layout/Stack';
import Link from "next/link";

export default function Home() {
    const hero = (
        <div className="text-center flex flex-col items-center gap-4">
            <h1 className="text-3xl sm:text-4xl md:text-5xl tracking-tight font-medium text-gray-50 leading-tight">
                <span className="block">Real-time updates</span>
                <span className="block text-blue-400">about what matters</span>
            </h1>
            <p className="max-w-md mx-auto text-sm sm:text-base md:text-lg text-gray-300 leading-relaxed md:max-w-3xl">
                Stay on top of current events without the overwhelm.
            </p>
            <div className="max-w-md">
                <div className="rounded-md shadow">
                    <Link
                        href="/summarizer"
                        className="group w-full flex items-center justify-center p-3 md:p-4 text-base md:text-lg font-medium rounded-md text-gray-50 bg-blue-600 hover:bg-blue-700 transition-colors duration-DEFAULT focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 focus-visible:ring-offset-gray-900 mb-4"
                    >
                        <span>Demo</span>
                    </Link>
                </div>
            </div>
        </div>
    );

    const features = (
        <section className="my-8 w-[90%] mx-auto flex flex-col items-center">
            <Stack spacing="relaxed">
                <div className="bg-gray-800 rounded-lg p-4 lg:p-6">
                    <Stack spacing="default" className="items-center">
                        <h3 className="text-base sm:text-lg font-medium text-blue-400 leading-snug">Real-Time Intelligence</h3>
                        <p className="text-sm sm:text-base text-gray-300 leading-normal text-center">Transform live discussions into clear, actionable insights</p>
                    </Stack>
                </div>
                <div className="bg-gray-800 rounded-lg p-4 lg:p-6">
                    <Stack spacing="default" className="items-center">
                        <h3 className="text-base sm:text-lg font-medium text-blue-400 leading-snug">Seamless Integration</h3>
                        <p className="text-sm sm:text-base text-gray-300 leading-normal text-center">AI-powered summaries with enterprise-grade security</p>
                    </Stack>
                </div>
                <div className="bg-gray-800 rounded-lg p-4 lg:p-6">
                    <Stack spacing="default" className="items-center">
                        <h3 className="text-base sm:text-lg font-medium text-blue-400 leading-snug">Periodic Updates</h3>
                        <p className="text-sm sm:text-base text-gray-300 leading-normal text-center">Get live updates on your favorite topics</p>
                    </Stack>
                </div>
            </Stack>
        </section>
    );

    return (
        <div className="lg:w-[90%] sm:w-[100%] h-screen mx-auto bg-gray-900 flex flex-col">
            <header className="py-4 flex justify-between items-center mx-8">
                <div className="text-xl sm:text-2xl font-medium text-gray-50" role="banner">NewsNow</div>
                <nav className="flex justify-between items-center">
                    <Stack direction="horizontal" spacing="default">
                        <Link
                            href="https://github.com/ghsaboias/news-now"
                            className="px-4 py-2 text-sm font-medium rounded-md text-gray-50 bg-blue-600 hover:bg-blue-700 transition-colors duration-DEFAULT"
                            target="_blank"
                        >
                            <span>About</span>
                        </Link>
                    </Stack>
                </nav>
            </header>
            <div className="flex-grow flex flex-col justify-center items-center gap-4">



                {hero}
                {features}


            </div>
            <footer className="pb-8 w-full">
                <div className="text-center text-gray-400 text-sm">
                    © 2024 NewsNow. All rights reserved.
                </div>
            </footer>
        </div>
    );
}

</file>

<file path="new-app/src/app/api/messages/route.ts">
import { DiscordClient } from '@/services/discord/client';
import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
    const searchParams = request.nextUrl.searchParams;
    const channelId = searchParams.get('channelId');
    const channelName = searchParams.get('channelName');
    const timeframe = searchParams.get('timeframe') || '24h';

    if (!channelId || !channelName) {
        return NextResponse.json(
            { error: `${!channelId ? 'Channel ID' : 'Channel name'} is required` },
            { status: 400 }
        );
    }

    const hours = timeframe === '1h' ? 1 : timeframe === '4h' ? 4 : 24;

    try {
        const client = new DiscordClient();
        const messages = await client.fetchMessagesInTimeframe(channelId, hours);
        return NextResponse.json(messages);
    } catch (error) {
        console.error('Error fetching messages:', error);
        return NextResponse.json(
            { error: 'Failed to fetch messages' },
            { status: 500 }
        );
    }
}
</file>

<file path="new-app/src/app/api/summary/route.ts">
import { AnthropicClient } from '@/services/claude/client';
import { ReportGenerator } from '@/services/report/generator';
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
    try {
        const searchParams = request.nextUrl.searchParams;
        const channelId = searchParams.get('channelId');
        const channelName = searchParams.get('channelName');

        if (!channelId || !channelName) {
            return NextResponse.json(
                { error: 'Channel ID and name are required' },
                { status: 400 }
            );
        }

        if (!process.env.ANTHROPIC_API_KEY) {
            return NextResponse.json(
                { error: 'ANTHROPIC_API_KEY is not configured' },
                { status: 500 }
            );
        }

        const { messages, previousSummary, timeframe = '1h' } = await request.json();

        if (!messages || !Array.isArray(messages)) {
            return NextResponse.json(
                { error: 'Messages array is required in request body' },
                { status: 400 }
            );
        }

        if (messages.length === 0) {
            console.log(`[Summary Generator] No messages found for channel ${channelName} in timeframe ${timeframe}`);
            return NextResponse.json(
                {
                    error: 'No messages found',
                    code: 'NO_MESSAGES',
                    details: {
                        channelId,
                        channelName,
                        timeframe
                    }
                },
                { status: 204 }
            );
        }

        const claudeClient = new AnthropicClient(process.env.ANTHROPIC_API_KEY);
        const reportGenerator = new ReportGenerator(claudeClient);

        const requestedHours = timeframe === '24h' ? 24 : timeframe === '4h' ? 4 : 1;

        const firstMessage = messages[0];
        const lastMessage = messages[messages.length - 1];

        const actualTimeframeHours = messages.length > 0 && firstMessage?.timestamp && lastMessage?.timestamp ?
            Math.ceil((new Date(lastMessage.timestamp).getTime() -
                new Date(firstMessage.timestamp).getTime()) / (1000 * 60 * 60)) : requestedHours;

        console.log(`[Summary Generator] Timeframe analysis:`, {
            requestedTimeframe: `${requestedHours}h`,
            actualTimeframeHours,
            firstMessage: firstMessage?.timestamp || null,
            lastMessage: lastMessage?.timestamp || null,
            messageCount: messages.length
        });

        const summary = await reportGenerator.createAISummary(
            messages,
            channelName,
            requestedHours,
            previousSummary
        );

        if (!summary) {
            return NextResponse.json(
                { error: 'Failed to generate summary' },
                { status: 500 }
            );
        }

        return NextResponse.json(summary);
    } catch (error) {
        console.error('Error in /api/summary:', error);
        return NextResponse.json(
            { error: 'Failed to generate summary' },
            { status: 500 }
        );
    }
} 
</file>

<file path="new-app/src/app/api/channels/route.ts">
import { DiscordChannel } from '@/types';
import { config } from '@/utils/config';
import axios from 'axios';
import { NextResponse } from 'next/server';

export async function GET() {
    try {
        const response = await axios.get(`https://discord.com/api/v10/guilds/${config.GUILD_ID}/channels`, {
            headers: {
                Authorization: `${config.DISCORD_TOKEN}`,
                'Content-Type': 'application/json',
            },
        });

        // Filter channels as before
        const allowedEmojis = new Set(['🔵', '🟡', '🔴', '🟠', '⚫']);
        const filteredChannels = response.data.filter((channel: DiscordChannel) => {
            if (channel.type !== 0) return false;
            if (channel.parent_id === '1112044935982633060') return true;
            if (!channel.name || channel.name.includes('godly-chat')) return false;
            if ((channel.position || 0) >= 30) return false;

            const firstChar = Array.from(channel.name)[0] || '';
            return allowedEmojis.has(firstChar);
        });

        return NextResponse.json(filteredChannels);
    } catch (error: any) {
        console.error('Error fetching Discord channels:', error.message);
        return NextResponse.json(
            { error: 'Failed to fetch Discord channels' },
            { status: 500 }
        );
    }
} 
</file>

<file path="new-app/src/app/summarizer/layout.tsx">
import { ReportsProvider } from '@/context/ReportsContext';
import { ReactNode } from 'react';

// Log when the layout is rendered
console.log('[SummarizerLayout] Initializing');
const startTime = performance.now();

export default function SummarizerLayout({
  children,
}: {
  children: ReactNode;
}) {
  console.log(`[SummarizerLayout] Render completed in ${performance.now() - startTime}ms`);
  return <ReportsProvider>{children}</ReportsProvider>;
} 
</file>

<file path="new-app/src/app/summarizer/page.tsx">
'use client';

import { Button } from '@/components/common/Button';
import { EmptyStateMessage } from '@/components/common/EmptyStateMessage';
import { ChannelSelect } from '@/components/controls/ChannelSelect';
import { ControlsContainer } from '@/components/controls/ControlsContainer';
import { TimeSelect, TimeframeOption, TimeframeValue } from '@/components/controls/TimeSelect';
import { useReports } from '@/context/ReportsContext';
import { useToast } from '@/context/ToastContext';
import { useDiscordChannels } from '@/hooks/useDiscordChannels';
import { useState } from 'react';
import { Loader } from 'react-feather';

const TIMEFRAME_OPTIONS: TimeframeOption[] = [
    { value: '1h', label: 'Last Hour' },
    { value: '4h', label: 'Last 4 Hours' },
    { value: '24h', label: 'Last 24 Hours' },
];

export default function SummarizerPage() {
    const { currentReport, setCurrentReport } = useReports();
    const { channels, isLoading, error } = useDiscordChannels();
    const { showToast } = useToast();
    const [selectedChannel, setSelectedChannel] = useState<string>('');
    const [selectedTimeframe, setSelectedTimeframe] = useState<TimeframeValue>('1h');
    const [isGenerating, setIsGenerating] = useState(false);
    const [noMessagesFound, setNoMessagesFound] = useState(false);

    const selectedChannelObj = channels.find(ch => ch.id === selectedChannel);

    const handleGenerateSummary = async () => {
        if (!selectedChannel || !selectedChannelObj) {
            showToast({ text: 'Please select a channel', type: 'error' });
            return;
        }

        setIsGenerating(true);
        setNoMessagesFound(false);

        try {
            // Step 1: Fetch messages
            const messagesResponse = await fetch(
                `/api/messages?channelId=${selectedChannel}&channelName=${encodeURIComponent(selectedChannelObj.name)}&timeframe=${selectedTimeframe}`
            );
            if (!messagesResponse.ok) {
                throw new Error('Failed to fetch messages');
            }
            const messages = await messagesResponse.json();

            // Check if messages array is empty
            if (!messages || messages.length === 0) {
                console.log(`No messages found for channel ${selectedChannelObj.name} in the last ${selectedTimeframe}`);
                setNoMessagesFound(true);
                setIsGenerating(false);
                return;
            }

            // Step 2: Generate summary
            const summaryResponse = await fetch(
                `/api/summary?channelId=${selectedChannel}&channelName=${encodeURIComponent(selectedChannelObj.name)}`,
                {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ messages, timeframe: selectedTimeframe }),
                }
            );
            if (!summaryResponse.ok) {
                throw new Error('Failed to generate summary');
            }
            const summary = await summaryResponse.json();

            // Step 3: Create report and update context
            const report = {
                id: `${selectedChannel}-${Date.now()}`,
                channelId: selectedChannel,
                channelName: selectedChannelObj.name,
                timestamp: new Date().toISOString(),
                timeframe: {
                    type: selectedTimeframe,
                    start: new Date(Date.now() - (selectedTimeframe === '24h' ? 24 : selectedTimeframe === '4h' ? 4 : 1) * 60 * 60 * 1000).toISOString(),
                    end: new Date().toISOString(),
                },
                messageCount: messages.length,
                summary,
            };
            setCurrentReport(report);
            showToast({ text: 'Summary generated successfully', type: 'success' });
        } catch (err) {
            if (err instanceof Error) {
                showToast({ text: `Error: ${err.message}`, type: 'error' });
            } else {
                showToast({ text: 'An unknown error occurred', type: 'error' });
            }
            console.error('Summary generation failed:', err);
        } finally {
            setIsGenerating(false);
        }
    };

    return (
        <div className="p-6">
            <ControlsContainer>
                <ChannelSelect
                    channels={channels}
                    selectedChannelId={selectedChannel}
                    onSelect={setSelectedChannel}
                    disabled={isLoading || isGenerating}
                />
                <TimeSelect
                    options={TIMEFRAME_OPTIONS}
                    value={selectedTimeframe}
                    onChange={setSelectedTimeframe}
                    disabled={isLoading || isGenerating || !selectedChannel}
                />
                <Button
                    variant="primary"
                    disabled={isLoading || isGenerating || !selectedChannel}
                    icon={isGenerating ? <Loader className="animate-spin" /> : undefined}
                    onClick={handleGenerateSummary}
                >
                    Generate Summary
                </Button>
            </ControlsContainer>
            <div className="mt-6">
                {error ? (
                    <div className="text-red-500">{error}</div>
                ) : noMessagesFound ? (
                    <EmptyStateMessage
                        channelName={selectedChannelObj?.name || 'selected channel'}
                        timeframe={selectedTimeframe}
                    />
                ) : currentReport ? (
                    <div className="bg-gray-800 p-4 rounded-lg">
                        <h2 className="text-xl font-bold text-gray-50">{currentReport.summary.headline}</h2>
                        <p className="text-gray-300 mt-2">{currentReport.summary.location}</p>
                        <p className="text-gray-200 mt-2">{currentReport.summary.body}</p>
                        <div className="mt-4">
                            <h3 className="text-gray-400">Sources:</h3>
                            <ul className="list-disc pl-5 text-gray-300">
                                {currentReport.summary.sources.map((source, idx) => (
                                    <li key={idx}>{source}</li>
                                ))}
                            </ul>
                        </div>
                    </div>
                ) : (
                    <p className="text-gray-400">No report generated yet. Select a channel and timeframe to generate a summary.</p>
                )}
            </div>
        </div>
    );
}
</file>

<file path="new-app/src/utils/config.ts">
interface Config {
  DISCORD_TOKEN: string;
  GUILD_ID: string;
  REQUEST_TIMEOUT: number;
  MAX_BATCH_SIZE: number;
}

// In Next.js, we need to check if we're on the client side
const isClient = typeof window !== 'undefined';

// Only check for required env vars on the server side
if (!isClient) {
  if (!process.env.DISCORD_TOKEN) {
    throw new Error('DISCORD_TOKEN environment variable is required');
  }
}

// GUILD_ID can be accessed on both client and server
if (!process.env.NEXT_PUBLIC_GUILD_ID) {
  throw new Error('NEXT_PUBLIC_GUILD_ID environment variable is required');
}

export const config: Config = {
  DISCORD_TOKEN: process.env.DISCORD_TOKEN || '',
  GUILD_ID: process.env.NEXT_PUBLIC_GUILD_ID || '',
  REQUEST_TIMEOUT: 30000, // 30 seconds
  MAX_BATCH_SIZE: 1000, // Maximum number of messages to fetch
}; 
</file>

<file path="new-app/src/components/layout/Stack.tsx">
import { ReactNode } from 'react';

interface StackProps {
  /** Stack content */
  children: ReactNode;
  /** Stack direction */
  direction?: 'horizontal' | 'vertical';
  /** Space between items */
  spacing?: 'tight' | 'default' | 'relaxed';
  /** Whether items should wrap to next line (only applies to horizontal stacks) */
  wrap?: boolean;
  /** Whether to add a divider between items */
  divider?: boolean;
  /** Additional CSS classes */
  className?: string;
  /** HTML element to render as */
  as?: 'div' | 'section' | 'ul' | 'ol';
}

const spacingStyles = {
  tight: 'gap-2',     // 8px  - Tight spacing (buttons, badges)
  default: 'gap-3',   // 12px - Default spacing (form fields)
  relaxed: 'gap-4'    // 16px - Relaxed spacing (cards, sections)
} as const;

/**
 * Stack component for consistent vertical/horizontal layouts
 * 
 * @example
 * ```tsx
 * // Vertical stack (default)
 * <Stack spacing="default">
 *   <div>Item 1</div>
 *   <div>Item 2</div>
 * </Stack>
 * 
 * // Horizontal stack with wrapping
 * <Stack direction="horizontal" spacing="tight" wrap>
 *   <Button>Action 1</Button>
 *   <Button>Action 2</Button>
 * </Stack>
 * ```
 */
export function Stack({
  children,
  direction = 'vertical',
  spacing = 'default',
  wrap = false,
  divider = false,
  className = '',
  as: Component = 'div'
}: StackProps) {
  return (
    <Component
      className={`
        flex
        ${direction === 'horizontal' ? 'flex-row' : 'flex-col'}
        ${wrap ? 'flex-wrap' : ''}
        ${spacingStyles[spacing]}
        ${divider ? direction === 'horizontal' ? 'divide-x' : 'divide-y' : ''}
        ${className}
      `}
    >
      {children}
    </Component>
  );
} 
</file>

<file path="new-app/src/components/controls/ChannelSelect.tsx">
import { DiscordChannel } from '@/types';

interface ChannelSelectProps {
  channels: DiscordChannel[];
  selectedChannelId: string;
  onSelect: (channelId: string) => void;
  disabled?: boolean;
}

export function ChannelSelect({
  channels,
  selectedChannelId,
  onSelect,
  disabled = false
}: ChannelSelectProps) {
  return (
    <div className="w-full">
      <div className="relative">
        <select
          value={selectedChannelId}
          onChange={(e) => onSelect(e.target.value)}
          disabled={disabled}
          className="
            w-full px-4 py-2.5 bg-gray-800/80 border border-gray-700 rounded-lg text-white
            appearance-none cursor-pointer transition-colors
            hover:bg-gray-700 hover:border-gray-600
            focus:ring-2 focus:ring-blue-500 focus:border-blue-500 focus:outline-none
            disabled:opacity-50 disabled:cursor-not-allowed
          "
        >
          <option value="">Select a channel</option>
          {channels.map((channel) => (
            <option key={channel.id} value={channel.id} className="bg-gray-800">
              {channel.name}
            </option>
          ))}
        </select>
        <div className="absolute inset-y-0 right-0 flex items-center pr-4 pointer-events-none">
          <svg
            className="w-5 h-5 text-gray-400"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth="2"
              d="M19 9l-7 7-7-7"
            />
          </svg>
        </div>
      </div>
    </div>
  );
} 
</file>

<file path="new-app/src/components/controls/ControlsContainer.tsx">
import Link from 'next/link';
import { ReactNode } from 'react';
import { Stack } from '../layout/Stack';

interface ControlsContainerProps {
  children: ReactNode;
}

export function ControlsContainer({ children }: ControlsContainerProps) {
  return (
    <Stack className="h-full">
      {/* Sticky Header */}
      <div className="flex-none">
        <div className="flex items-center justify-center p-4">
          <Link href="/">
            <h1 className="text-2xl font-bold text-white">NewsNow</h1>
          </Link>
        </div>
      </div>

      {/* Controls */}
      <div className="flex-none bg-gray-800/50 backdrop-blur-sm rounded-xl p-4 mb-6">
        <Stack spacing="default">{children}</Stack>
      </div>
    </Stack>
  );
}
</file>

<file path="new-app/src/components/controls/TimeSelect.tsx">
import { Button } from '@/components/common/Button';

export type TimeframeValue = '1h' | '4h' | '24h';

export interface TimeframeOption {
  value: TimeframeValue;
  label: string;
}

export interface TimeSelectProps {
  /** Currently selected timeframe */
  value: TimeframeValue;
  /** Called when selection changes */
  onChange: (value: TimeframeValue) => void;
  /** Available timeframe options */
  options: TimeframeOption[];
  /** Disabled state */
  disabled?: boolean;
  className?: string;
}

/**
 * Time range selector with multiple options
 * 
 * @example
 * ```tsx
 * <TimeSelect
 *   value="1h"
 *   onChange={setTimeframe}
 *   options={[
 *     { value: '1h', label: 'Last Hour' },
 *     { value: '4h', label: 'Last 4 Hours' },
 *     { value: '24h', label: 'Last 24 Hours' },
 *   ]}
 *   disabled={false}
 * />
 * ```
 */
export function TimeSelect({
  options,
  value,
  onChange,
  disabled,
  className = ''
}: TimeSelectProps) {
  return (
    <div className={`w-full ${className}`}>
      <div className="grid grid-cols-3 gap-2">
        {options.map((option) => (
          <Button
            key={option.value}
            onClick={() => onChange(option.value)}
            disabled={disabled}
            variant={value === option.value ? 'primary' : 'secondary'}
            size="sm"
            fullWidth
          >
            {option.label}
          </Button>
        ))}
      </div>
    </div>
  );
} 
</file>

<file path="new-app/src/components/common/Button.tsx">
import { ReactNode } from 'react';
import { Loader } from 'react-feather';

interface ButtonProps {
  /** Button content */
  children: ReactNode;
  /** Visual style variant */
  variant?: 'primary' | 'secondary' | 'danger';
  /** Size variant */
  size?: 'sm' | 'md' | 'lg';
  /** Optional icon to show before text */
  icon?: ReactNode;
  /** Loading state */
  loading?: boolean;
  /** Disabled state */
  disabled?: boolean;
  /** Full width button */
  fullWidth?: boolean;
  /** Additional CSS classes */
  className?: string;
  /** Click handler */
  onClick?: () => void;
  /** Button type */
  type?: 'button' | 'submit' | 'reset';
  /** Optional title for hover tooltip */
  title?: string;
}

const variantStyles = {
  primary: `
    bg-blue-600 text-gray-50
    hover:bg-blue-700
    focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 focus-visible:ring-offset-gray-900
    focus:outline-none
    disabled:bg-blue-600/50
  `,
  secondary: `
    bg-gray-700/50 text-gray-200
    hover:bg-gray-700 hover:text-gray-50
    focus-visible:ring-2 focus-visible:ring-gray-500 focus-visible:ring-offset-2 focus-visible:ring-offset-gray-900
    focus:outline-none
    disabled:bg-gray-700/25
  `,
  danger: `
    bg-gray-700/50 text-error-500
    hover:bg-gray-700 hover:text-error-400
    focus-visible:ring-2 focus-visible:ring-error-500 focus-visible:ring-offset-2 focus-visible:ring-offset-gray-900
    focus:outline-none
    disabled:bg-gray-700/25
  `
} as const;

const sizeStyles = {
  sm: 'p-2 text-sm gap-2 rounded-md',
  md: 'p-3 text-sm gap-3 rounded-lg',
  lg: 'p-4 text-base gap-3 rounded-lg'
} as const;

/**
 * Base button component with consistent styling
 * 
 * @example
 * ```tsx
 * // Primary button (medium size)
 * <Button variant="primary">Create Report</Button>
 * 
 * // Secondary button with icon (small size)
 * <Button variant="secondary" size="sm" icon={<RefreshCw />}>Retry</Button>
 * 
 * // Large primary button
 * <Button variant="primary" size="lg">Get Started</Button>
 * ```
 */
export function Button({
  children,
  variant = 'primary',
  size = 'md',
  icon,
  loading = false,
  disabled = false,
  fullWidth = false,
  className = '',
  onClick,
  type = 'button',
  title
}: ButtonProps) {
  // Determine which icon to show (loading spinner or provided icon)
  const buttonIcon = loading ? <Loader className="animate-spin" /> : icon;

  return (
    <button
      type={type}
      onClick={onClick}
      disabled={disabled || loading}
      title={title}
      className={`
        inline-flex items-center justify-center
        font-medium
        transition-colors duration-DEFAULT
        disabled:opacity-50 disabled:cursor-not-allowed
        ${variantStyles[variant]}
        ${sizeStyles[size]}
        ${fullWidth ? 'w-full' : ''}
        ${className}
      `}
    >
      {buttonIcon && <span className="flex-shrink-0">{buttonIcon}</span>}
      <span>{children}</span>
    </button>
  );
} 
</file>

<file path="new-app/src/components/common/EmptyStateMessage.tsx">
'use client';

import { TimeframeValue } from '@/components/controls/TimeSelect';
import { AlertCircle } from 'react-feather';

interface EmptyStateMessageProps {
    channelName: string;
    timeframe: TimeframeValue;
}

export function EmptyStateMessage({ channelName, timeframe }: EmptyStateMessageProps) {
    const timeframeText = timeframe === '1h' ? 'hour' : timeframe === '4h' ? '4 hours' : '24 hours';

    return (
        <div className="bg-gray-800 p-6 rounded-lg border border-gray-700 text-center">
            <div className="flex justify-center mb-4">
                <AlertCircle className="text-amber-400 h-12 w-12" />
            </div>
            <h3 className="text-xl font-medium text-gray-200 mb-2">No Messages Found</h3>
            <p className="text-gray-400 mb-4">
                There were no messages in <span className="font-medium text-gray-300">{channelName}</span> during the last {timeframeText}.
            </p>
            <div className="bg-gray-700/50 p-4 rounded text-left">
                <h4 className="text-gray-300 font-medium mb-2">Suggestions:</h4>
                <ul className="text-gray-400 list-disc pl-5 space-y-1">
                    <li>Try selecting a different timeframe</li>
                    <li>Check another channel</li>
                    <li>Verify that the channel is active</li>
                </ul>
            </div>
        </div>
    );
} 
</file>

<file path="new-app/src/components/common/Toast.tsx">
import { useEffect } from 'react';
import { AlertCircle, Check, X } from 'react-feather';

interface ToastProps {
  message: string;
  onClose: () => void;
  type?: 'success' | 'error';
  duration?: number;
}

export function Toast({
  message,
  onClose,
  type = 'success',
  duration = type === 'error' ? 5000 : 3000
}: ToastProps) {
  useEffect(() => {
    const timer = setTimeout(onClose, duration);
    return () => clearTimeout(timer);
  }, [duration, onClose]);

  const Icon = type === 'success' ? Check : AlertCircle;
  const iconColor = type === 'success' ? 'text-emerald-400' : 'text-red-400';
  const bgColor = type === 'success' ? 'bg-gray-800/95' : 'bg-red-900/95';
  const borderColor = type === 'success' ? 'border-gray-600/50' : 'border-red-800/50';

  return (
    <div className={`
      fixed bottom-4 right-4 
      flex items-center gap-3 px-4 py-3
      ${bgColor}
      text-gray-50
      rounded-lg 
      border ${borderColor}
      shadow-lg
      backdrop-blur-md
      transition-all duration-200
      animate-in fade-in slide-in-from-bottom-4
    `}>
      <Icon className={`w-4 h-4 ${iconColor}`} />
      <span className="text-sm font-medium">{message}</span>
      <button
        onClick={onClose}
        className="
          ml-2 p-1.5
          text-gray-400
          hover:text-gray-50
          hover:bg-gray-700/50
          active:bg-gray-600
          rounded-full 
          transition-colors duration-200
          focus:outline-none
          focus-visible:ring-2
          focus-visible:ring-blue-500
          focus-visible:ring-offset-2
          focus-visible:ring-offset-gray-800
        "
      >
        <X className="w-4 h-4" />
      </button>
    </div>
  );
} 
</file>

<file path="new-app/src/hooks/useDiscordChannels.ts">
import { DiscordClient } from '@/services/discord/client';
import { DiscordChannel } from '@/types';
import { useEffect, useState } from 'react';

export function useDiscordChannels() {
    const [channels, setChannels] = useState<DiscordChannel[]>([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    useEffect(() => {
        async function fetchChannels() {
            try {
                const client = new DiscordClient();
                const fetchedChannels = await client.fetchChannels();
                setChannels(fetchedChannels);
                setError(null);
            } catch (err) {
                setError('Failed to fetch Discord channels');
                console.error('Error fetching channels:', err);
            } finally {
                setIsLoading(false);
            }
        }

        fetchChannels();
    }, []);

    return { channels, isLoading, error };
} 
</file>

<file path="new-app/src/services/discord/client.ts">
import { DiscordChannel, DiscordMessage } from '@/types';
import { config } from '@/utils/config';
import axios, { AxiosInstance } from 'axios';

// API Limits
const MAX_REQUESTS_PER_SECOND = 48;
const REQUEST_WINDOW_MS = 1000;
const DEFAULT_BATCH_SIZE = 100;

// Cache configuration
const CACHE_CONFIG = {
    CHANNELS_TTL: 5 * 60 * 1000, // 5 minutes
    MESSAGES_TTL: 60 * 1000, // 1 minute
    MAX_CACHED_CHANNELS: 100,
    MAX_CACHED_MESSAGES: 1000,
};

// LRU Cache implementation for messages
class MessageCache {
    private cache: Map<
        string,
        {
            messages: DiscordMessage[];
            timestamp: number;
        }
    >;
    private maxSize: number;

    constructor(maxSize: number) {
        this.cache = new Map();
        this.maxSize = maxSize;
    }

    get(key: string): DiscordMessage[] | null {
        const entry = this.cache.get(key);
        if (!entry) return null;

        const now = Date.now();
        if (now - entry.timestamp > CACHE_CONFIG.MESSAGES_TTL) {
            this.cache.delete(key);
            return null;
        }

        return entry.messages;
    }

    set(key: string, messages: DiscordMessage[]): void {
        if (this.cache.size >= this.maxSize) {
            const oldestKey = this.cache.keys().next().value;
            if (oldestKey !== undefined) {
                this.cache.delete(oldestKey);
            }
        }

        this.cache.set(key, {
            messages,
            timestamp: Date.now(),
        });
    }

    clear(): void {
        this.cache.clear();
    }
}

export class DiscordClient {
    private readonly api: AxiosInstance;
    private readonly baseUrl = 'https://discord.com/api/v10';
    private requestQueue: Array<() => Promise<unknown>> = [];
    private isProcessingQueue = false;
    private requestsInCurrentWindow = 0;
    private windowStartTime = Date.now();
    private channelNames: Map<string, string> = new Map();
    public onMessageBatch?: (
        batchSize: number,
        botMessages: number,
        messages: DiscordMessage[]
    ) => Promise<void>;
    private cachedChannels: DiscordChannel[] | null = null;
    private lastChannelFetch = 0;
    private messageCache: MessageCache;

    constructor() {
        this.api = axios.create({
            baseURL: this.baseUrl,
            headers: { 'Content-Type': 'application/json', 'Authorization': config.DISCORD_TOKEN },
            timeout: config.REQUEST_TIMEOUT,
        });
        this.messageCache = new MessageCache(CACHE_CONFIG.MAX_CACHED_MESSAGES);
    }

    cleanup() {
        this.requestQueue = [];
        this.isProcessingQueue = false;
    }

    private async executeRequest<T>(request: () => Promise<T>, retries = 2): Promise<T> {
        return new Promise((resolve, reject) => {
            this.requestQueue.push(async () => {
                let lastError: Error | null = null;

                for (let attempt = 0; attempt <= retries; attempt++) {
                    try {
                        const result = await request();
                        resolve(result);
                        return;
                    } catch (error: any) {
                        lastError = error;

                        // Handle rate limiting
                        if (error?.response?.status === 429) {
                            const retryAfter = error.response.headers['retry-after'];
                            if (retryAfter) {
                                const waitTime = parseInt(retryAfter) * 1000;
                                console.log(`Rate limited. Waiting ${waitTime}ms before retry...`);
                                await new Promise((resolve) => setTimeout(resolve, waitTime));
                                continue;
                            }
                        }

                        if (attempt < retries) {
                            // Exponential backoff for other errors
                            const backoffTime = Math.pow(2, attempt) * 1000;
                            await new Promise((resolve) => setTimeout(resolve, backoffTime));
                            continue;
                        }
                    }
                }

                reject(lastError);
            });
            this.processQueue();
        });
    }

    private async processQueue() {
        if (this.isProcessingQueue) return;
        this.isProcessingQueue = true;

        while (this.requestQueue.length > 0) {
            const now = Date.now();
            if (now - this.windowStartTime >= REQUEST_WINDOW_MS) {
                this.requestsInCurrentWindow = 0;
                this.windowStartTime = now;
            }

            if (this.requestsInCurrentWindow >= MAX_REQUESTS_PER_SECOND) {
                const waitTime = REQUEST_WINDOW_MS - (now - this.windowStartTime);
                await new Promise((resolve) => setTimeout(resolve, waitTime));
                continue;
            }

            const request = this.requestQueue.shift();
            if (request) {
                this.requestsInCurrentWindow++;
                await request();
            }
        }

        this.isProcessingQueue = false;
    }

    async fetchChannels(): Promise<DiscordChannel[]> {
        try {
            // Cache check
            const now = Date.now();
            if (this.cachedChannels && now - this.lastChannelFetch < CACHE_CONFIG.CHANNELS_TTL) {
                return this.cachedChannels;
            }

            const response = await axios.get('/api/channels');
            const channels = response.data;

            // Update cache and channel names map
            this.cachedChannels = channels;
            this.lastChannelFetch = now;
            channels.forEach((channel: DiscordChannel) => {
                if (channel.name) {
                    this.channelNames.set(channel.id, channel.name);
                }
            });

            return channels;
        } catch (error) {
            console.error('Error fetching channels:', error);
            throw new Error('Failed to fetch Discord channels');
        }
    }

    async fetchMessageBatch(
        channelId: string,
        lastMessageId?: string,
        batchSize: number = DEFAULT_BATCH_SIZE
    ): Promise<DiscordMessage[]> {
        try {
            const params = new URLSearchParams({
                limit: Math.min(batchSize, DEFAULT_BATCH_SIZE).toString(),
            });
            if (lastMessageId) {
                params.append('before', lastMessageId);
            }
            console.log(`Fetching message batch for channel ${channelId} with params ${params.toString()}`);

            const response = await this.executeRequest(() =>
                this.api.get(`/channels/${channelId}/messages?${params.toString()}`)
            );
            console.log(`Fetched ${response.data.length} messages`);

            return response.data;
        } catch (error) {
            const err = error as Error;
            console.error('Error fetching message batch:', err.message);
            throw new Error(`Failed to fetch Discord messages: ${err.message}`);
        }
    }

    async fetchMessagesInTimeframe(
        channelId: string,
        hours: number = 24,
        lastMessageId?: string,
        topicId?: string,
        batchSize: number = DEFAULT_BATCH_SIZE
    ): Promise<DiscordMessage[]> {
        // Check cache first
        const cacheKey = `${channelId}-${hours}-${lastMessageId || 'initial'}`;
        const cachedMessages = this.messageCache.get(cacheKey);
        if (cachedMessages) {
            return cachedMessages;
        }

        let currentLastMessageId = lastMessageId;
        let batchCount = 0;
        let totalMessages = 0;
        const allMessages: DiscordMessage[] = [];

        // Calculate cutoff time
        const cutoffTime = new Date();
        cutoffTime.setHours(cutoffTime.getHours() - hours);

        const channelName = this.channelNames.get(channelId) || channelId;
        const timeframeStr = `${hours}h`;

        while (true) {
            const batch = await this.fetchMessageBatch(channelId, currentLastMessageId, batchSize);
            batchCount++;

            if (!batch || batch.length === 0) break;
            totalMessages += batch.length;

            // Process batch and get bot messages
            const batchMessages = batch.filter(
                (msg) =>
                    msg.author?.username === 'FaytuksBot' &&
                    msg.author?.discriminator === '7032' &&
                    new Date(msg.timestamp) >= cutoffTime
            );

            // Add filtered messages to result
            allMessages.push(...batchMessages);

            // Notify about the batch
            if (this.onMessageBatch) {
                await this.onMessageBatch(batch.length, batchMessages.length, batchMessages);
            }

            // Check if we should stop
            const lastMsgTime = new Date(batch[batch.length - 1].timestamp);
            if (lastMsgTime < cutoffTime) break;

            currentLastMessageId = batch[batch.length - 1].id;

            // Memory management: clear processed messages
            batch.length = 0;
        }

        console.log(
            `[${channelName}|${timeframeStr}] Processed ${totalMessages} messages in ${batchCount} batches`
        );

        // Cache the results
        this.messageCache.set(cacheKey, allMessages);

        return allMessages;
    }

    formatRawMessageReport(channelName: string, messages: DiscordMessage[]): string {
        let report = `📊 Report for #${channelName}\n\n`;

        if (messages.length === 0) {
            return report + 'No messages found in the specified timeframe\\.';
        }

        for (const msg of messages) {
            const timestamp = new Date(msg.timestamp)
                .toISOString()
                .replace(/T/, ' ')
                .replace(/\..+/, ' UTC');
            report +=
[Content truncated at 10,000 characters]
</file>

<file path="new-app/src/services/claude/client.ts">
import { ClaudeClient, ClaudeMessage, ClaudeResponse } from '@/types';
import Anthropic from '@anthropic-ai/sdk';

export class AnthropicClient implements ClaudeClient {
    private client: Anthropic;

    constructor(apiKey: string) {
        this.client = new Anthropic({
            apiKey,
        });
    }

    messages = {
        create: async (params: {
            model: string;
            max_tokens: number;
            system?: string;
            messages: ClaudeMessage[];
        }): Promise<ClaudeResponse> => {
            const response = await this.client.messages.create({
                model: params.model,
                max_tokens: params.max_tokens,
                system: params.system,
                messages: params.messages.map(msg => ({
                    role: msg.role === 'system' ? 'assistant' : msg.role,
                    content: msg.content,
                })),
            });

            // Handle the response content safely
            const text = response.content[0].type === 'text'
                ? response.content[0].text
                : '';

            return {
                content: [{ text }],
            };
        },
    };
} 
</file>

<file path="new-app/src/services/report/generator.ts">
import { AISummary, ClaudeClient, DiscordMessage } from '@/types';

export class ReportGenerator {
    private readonly MAX_TOKENS = 4000;

    constructor(
        private readonly claudeClient: ClaudeClient,
        private readonly logger: Console = console
    ) { }

    private formatMessagesForClaude(messages: DiscordMessage[]): string {
        return messages
            .sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime())
            .map((msg) => {
                const timestamp = new Date(msg.timestamp)
                    .toLocaleTimeString('en-US', {
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: false
                    });

                const parts = [`[${timestamp}]`];

                // Extract platform and handle from content
                let platform = '';
                let handle = '';

                if (msg.content.includes('twitter.com/')) {
                    platform = 'X';
                    const match = msg.content.match(/twitter\.com\/([^\/]+)/);
                    if (match) handle = match[1];
                } else if (msg.content.includes('t.me/')) {
                    platform = 'Telegram';
                    const match = msg.content.match(/t\.me\/([^\/]+)/);
                    if (match) handle = match[1];
                }

                // If not found in content, try embed title
                if (!platform && msg.embeds?.[0]?.title) {
                    const title = msg.embeds[0].title.toLowerCase();
                    if (title.includes('telegram:')) {
                        platform = 'Telegram';
                        const match = title.replace(/telegram:\s*/i, '').match(/@?([a-zA-Z0-9_]+)/);
                        if (match) handle = match[1];
                    } else if (title.includes('x:') || title.includes('twitter:')) {
                        platform = 'X';
                        const match = title.replace(/(?:x|twitter):\s*/i, '').match(/@?([a-zA-Z0-9_]+)/);
                        if (match) handle = match[1];
                    }
                }

                // Add platform and handle if found
                if (platform && handle) {
                    parts.push(`[${platform}] @${handle.replace(/^@/, '')}`);
                }

                // Add URL (from content)
                if (msg.content) {
                    parts.push(`Original: ${msg.content}`);
                }

                // Add embed information
                const embeds = msg.embeds || [];
                embeds.forEach((embed) => {
                    if (embed.title) parts.push(`Channel: ${embed.title}`);
                    if (embed.description) parts.push(`Content: ${embed.description}`);
                });

                // Add fields (quotes, translations, etc.)
                const fields = msg.embeds?.[0]?.fields || [];
                fields.forEach((field) => {
                    if (field.name.toLowerCase().includes('quote from')) {
                        const attribution = field.name.replace(/quote from:?\s*/i, '').trim();
                        parts.push(`Quote from ${attribution}: ${field.value}`);
                    } else if (field.name.toLowerCase() === 'translated from') {
                        parts.push(`[Translated from ${field.value}]`);
                    } else if (field.name.toLowerCase() !== 'source') { // Skip source as we have the URL
                        parts.push(`${field.name}: ${field.value}`);
                    }
                });

                // Add link if available
                if (msg.content) {
                    if (platform === 'Telegram' && handle) {
                        parts.push(`Link: t.me/${handle}`);
                    } else if (platform === 'X' && handle) {
                        parts.push(`Link: twitter.com/${handle}`);
                    }
                }

                return parts.join('\n');
            })
            .join('\n\n');
    }

    private validateSource(source: string): boolean {
        // Source format: "¹[YYYY-MM-DD HH:mm:ss UTC] content" or "¹⁰[YYYY-MM-DD HH:mm:ss UTC] content"
        const sourcePattern = /^(?:[¹²³⁴⁵⁶⁷⁸⁹][⁰¹²³⁴⁵⁶⁷⁸⁹]?)\[\d{4}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2}\s+UTC\]/;
        return sourcePattern.test(source);
    }

    private parseAISummary(text: string): AISummary {
        const lines = text.split('\n').map(line => line.trim()).filter(Boolean);

        if (lines.length < 3) {
            throw new Error('Invalid summary format: insufficient lines');
        }

        // Find the headline (first line in ALL CAPS)
        const headlineIndex = lines.findIndex(line =>
            line === line.toUpperCase() && line.length > 0
        );

        if (headlineIndex === -1) {
            throw new Error('Invalid summary format: no headline found');
        }

        // Location should be the line immediately after headline
        const locationIndex = headlineIndex + 1;
        const location = lines[locationIndex].trim();

        // Find the sources section
        const sourcesIndex = lines.findIndex((line, index) =>
            index > locationIndex && line.toLowerCase().startsWith('sources')
        );

        if (sourcesIndex === -1) {
            throw new Error('Invalid summary format: no sources section found');
        }

        const headline = lines[headlineIndex];
        const body = lines.slice(locationIndex + 1, sourcesIndex).join('\n');

        // Parse sources section
        const sources: string[] = [];
        let currentSource = '';
        let isInSourceBlock = false;

        for (let i = sourcesIndex + 1; i < lines.length; i++) {
            const line = lines[i];

            // Skip empty lines between source blocks
            if (!line && !isInSourceBlock) continue;

            // Start of a new source block
            if (line.match(/^\[\w+\] @\w+/)) {
                if (currentSource) {
                    sources.push(currentSource.trim());
                }
                currentSource = line;
                isInSourceBlock = true;
            }
            // Source reference line (starts with superscript)
            else if (line.match(/^[¹²³⁴⁵⁶⁷⁸⁹]\[/)) {
                if (currentSource) {
                    currentSource += '\n' + line;
                } else {
                    currentSource = line;
                }
                isInSourceBlock = true;
            }
            // Additional source information (indented)
            else if (line.startsWith('  ') && isInSourceBlock) {
                currentSource += '\n' + line;
            }
            // End of a source block
            else if (!line && isInSourceBlock) {
                if (currentSource) {
                    sources.push(currentSource.trim());
                    currentSource = '';
                }
                isInSourceBlock = false;
            }
        }

        // Add the last source if any
        if (currentSource) {
            sources.push(currentSource.trim());
        }

        // Validate sources
        if (!sources.length) {
            throw new Error('Invalid summary format: no valid sources found');
        }

        if (!headline || !location || !body) {
            throw new Error('Invalid summary format: missing required components');
        }

        return {
            headline,
            location,
            body,
            sources,
            raw_response: text,
            timestamp: new Date().toISOString(),
            period_start: new Date().toISOString(),
            period_end: new Date().toISOString()
        };
    }

    async createAISummary(
        messages: DiscordMessage[],
        channelName: string,
        requestedHours: number,
        previousSummary?: AISummary
    ): Promise<AISummary | null> {
        // Check for empty messages array and log the event
        if (!messages.length) {
            this.logger.info(`[Report Generator] No messages found for channel ${channelName} in the last ${requestedHours} hours`);
            // We return null here, but the API layer will handle this case specifically
            return null;
        }

        // Debug: Log message timestamp distribution
        const timestampDistribution: { [key: string]: number } = {};
        for (const msg of messages) {
            const hourKey = new Date(msg.timestamp).toISOString().slice(0, 13);
            timestampDistribution[hourKey] = (timestampDistribution[hourKey] || 0) + 1;
        }

        console.log(`[Report Generator] Message timestamp distribution for ${channelName} (${requestedHours}h):`,
            Object.entries(timestampDistribution)
                .sort(([a], [b]) => a.localeCompare(b))
                .map(([hour, count]) => `\n  ${hour}Z: ${count} messages`)
                .join('')
        );

        const formattedText = this.formatMessagesForClaude(messages);

        try {
            const response = await this.claudeClient.messages.create({
                model: 'claude-3-haiku-20240307',
                max_tokens: this.MAX_TOKENS,
                system: 'You are an experienced news wire journalist creating concise, clear updates. Your task is to report the latest developments while maintaining narrative continuity with previous coverage. Focus on what\'s new and noteworthy, using prior context only when it enhances understanding of current events.',
                messages: [
                    {
                        role: 'user',
                        content: this.createPrompt(formattedText, previousSummary),
                    },
                ],
            });

            if (!response?.content?.[0]?.text) {
                this.logger.error('Claude returned empty response');
                return null;
            }
            return this.parseAISummary(response.content[0].text);
   
[Content truncated at 10,000 characters]
</file>
</files>